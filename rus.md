# Пишем CSS на JavaScript

Зачастую программирование это всего лишь использование нужных инструментов.
Будь то фреймворк, библиотека или, как в моем случае, CSS препроцессор.
Возможно вы не осознаете, но LESS и SASS сильно связывают руки. Я решил
избавиться от этого тем, что написал свой CSS препроцессор. Я отказался от CSS
и перенес все в мир JavaScript. Эта статья о [AbsurdJS][1]: небольшом Node.js
модуле, который изменил мой рабочий процесс целиком и полностью.

## Идея {#concept}

![Пишем CSS на JavaScript][2]

Если вы часто пишете CSS, то наверняка вы используете препроцессоры. Популярных
их всего два - LESS и SASS. Оба берут что-то похожее на CSS, творят над этим
магию и выдают в итоге нормальный, чистый CSS. Я, всего-навсего, заменил
инструмент и формат исходных данных. Я не стал изобретать новые языкы и
синтаксисы, потому что тогда надо было бы разбираться с парсерами и
компиляторами. Как же я рад, что существует Node.js и что я решил им
воспользоваться. У меня было достаточно проектов с LESS, так что я уже
использовал Node.js для компиляции стилей. Заменить один модуль на другой было
намного проще, чем внедрять что-то абсолютно новое.

## Формат ввода {#input}

![Пишем CSS на JavaScript][3]

На мой взгляд ближе всего к CSS формату оказывается JSON - именно его AbsurdJS
и принимает в качестве исходного кода. Конечно же у такого преобразования есть
несколько минусов. Вам придется оборачивать некоторые свойства в кавычки, как и
все значения. Это будет занимать больше времени чем обычно, но, как вы увидете
ниже, оно того стоит.

## В начале был ... JavaScript файл {#in-the-beginning}

Вот так выглядит просто LESS файл:

    .main-nav {
        background: #333;
        color: #000;
        font-weight: bold;
        p {
            font-size: 20px;
        }
    }

А так выглядит его еквивалент на AbsurdJS. Это простой Node.js модуль:

    module.exports = function(api) {
        api.add({
            ".main-nav": {
                background: "#333",
                color: "#000",
                "font-weight": "bold",
                p: {
                    "font-size": "20px"
                }
            }
        })
    }

Вы должны определить функцию `module.exports`. Она будет принимать в качестве
параметра ссылку на API, который содержит несколько методов, но самый важный
из них - `add`. Просто передайте в этот метод JSON-объект и он будет
сконвертирован в CSS.

Что бы преобразовать LESS файл нам надо установить LESS-компилятор командой
`npm install -g less` и запустить

    lessc .\css.less > styles.less.css

С AbsurdJS все точно так же. Устанавливается пакетным менеджеро node -
`npm install -g absurd`.

    absurd -s css.js -o styles.absurd.css

В качестве параметров надо указать исходный файл и конечный файл. Результат
будет тот же.

## Правда {#truth}

Возможно у вас в проекте по настоящему красивые и легко-читаемые LESS или SASS
файлы, но только конечный скомпилированный CSS имеет значение. К сожалению,
результат далеко не всегда радует.

### Объединение {#combining}

Давайте рассмотрим следующий пример:

    .main-nav {
        background: #333;
    }
    .main-content {
        background: #333;
    }

Если вы прогоните его через распространенные препроцессоры, то на выходе вы вы
получите тоже самое. Однако если бы вы воспользовались AbsurdJS, исходный код
выгляел бы так:

    module.exports = function(api) {
        api.add({
            ".main-nav": {
                background: "#333"
            },
            ".main-content": {
                background: "#333"
            }
        })
    }

А после компиляции вы бы получили такой код:

    .main-nav, .main-content {
        background: #333;
    }

В SASS есть возможность использовать *placeholders*, которые делают тоже самое.
Однако там свои проблемы. Placeholders не принимают параметров и их надо
повторять в каждом селекторе, который необходимо расширить. Мое решение просто
проверяет все правила и объединяет одинаковые. Давайте рассмотрим пример
посложнее:

    {
        ".main-nav": {
            background: "#333",
            ".logo": {
                color: "#9f0000",
                margin: 0
            }
        },
        ".main-content": {
            background: "#333"
        },
        section: {
            color: "#9f0000",
            ".box": {
                margin: 0
            }
        }
    }

Результат:

    .main-nav, .main-content {
        background: #333;
    }
    .main-nav .logo, section {
        color: #9f0000;
    }
    .main-nav .logo, section .box {
        margin: 0;
    }
    section .box {
        padding: 10px;
        font-size: 24px;
    }

Все идентичные стили объеденены в одно определение. Я знаю что в наши дни
браузеры достаточно быстры и это не самая важная оптимизация, но так можно
уменьшить размер конечного файла.

### Переопределение {#overwriting}

Все знают что если у вас два одинаковых селектора и они содержать определения
одного и того же стиля с разными значениями, то второе определение перезапишет
первое. Следующий код не изменится при компиляции через LESS/SASS:

    .main-nav {
       font-size: 20px;
    }
    .main-nav {
       font-size: 30px;
    }

Однако я считаю что такой подход заставляет браузер совершать лишние действия:
он должен будет понять что существует другое опредление с таким же селектором и
определением, а затем вычислить правильно значение. Разве не лучше избегать
таких ситуаций указывая сразу:

    .main-nav {
        font-size: 30px;
    }

AbsurdJS заботится об этом сам и выдает только одно определение. Входной код
может выглядеть так:

    {
        ".main-nav": {
            "font-size": "20px"
        },
        ".main-nav": {
            "font-size": "30px"
        }
    }

К тому же такой подход делает процесс отлова ошибок проще, так как в итоге не
будет длинных цепочек перезаписи.

### Гибкость {#flexibility}

Итак, у нас есть примеси, переменные, расширения, функции, но как только вы
начнете использовать их для написания вещей посложнее примеров вы встрянете.
Например примеси. Я был бы рад использовать примесь, которая будет
наследоваться от другой примеси. Это невозможно сделать в LESS, потому что там
нельзя использовать примесь, объявленную в другой примеси. Возможно причина в
области видимости, не знаю. В SASS также есть несолько [недостатков][4]
относительно интерполяции переменных. В целом, сделать хорошую архитектуру в
less коде достаточно сложно. Вам придется писать много, очень много кода и даже
в этом случае вы можете не получить желаемого эффекта. Основная причина таких
проблем заключается в том что и LESS, и SASS, вводят новый синтаксис, новые
правила и изобретают новый компилятор. В то время как мы можем исключить все
эти проблемы разом всего лишь работая с JavaScript-ом.

AbsurdJS содержит так называемый *storage*. Он может сохранять все что угодно и
предоставляет к этому доступ из других определений. К примеру:

    // B.js
    module.exports = function(api) {
        api.storage("theme", function(type) {
            switch(type) {
                case "dark": return { color: "#333", "font-size": "20px" }; break;
                case "light": return { color: "#FFF", "font-size": "22px" }; break;
                default: return { color: "#999", "font-size": "18px" };
            }
        });
    }

    // A.js
    module.exports = function(api) {
        api
        .import(__dirname + "/B.js")
        .add({
            ".main-nav": [
                {
                    "font-size": "16px",
                    padding: 0,
                    margin: 0
                },
                api.storage("theme")("dark")
            ]
        });
    }


В итоге вы получите:

    .main-nav {
        color: #333;
        font-size: 20px;
        padding: 0;
        margin: 0;
    }

Использование storage на самом деле немного уродливло. В том смысле, что вам
необходимо присвоить селектору массив и затем вызвать `api.storage`. Я
использовал такой подход по началу, но потом решил внедрить нечто заметно
удобнее. Функциональность, которую я всегда хотел - возможность создавть свои
свойства и экономить этим уйму строк кода. К примеру, давайте создадим новое
свойство `theme` и укажем его возможные значения.

    // B.js - definition of the plugin
    module.exports = function(api) {
        api.plugin('theme', function(api, type) {
            switch(type) {
                case "dark": return { color: "#333", "font-size": "20px" }; break;
                case "light": return { color: "#FFF", "font-size": "22px" }; break;
                default: return { color: "#999", "font-size": "18px" };
            }
        });
    }

    // A.js - its usage
    module.exports = function(api) {
        api
        .import(__dirname + "/B.js")
        .add({
            ".header": {
                theme: "light"
            }
        })
    }

В итоге получится то же самое:

    .header {
        color: #FFF;
        font-size: 22px;
    }


## Заключение {#conclusion}

[AbsurdJS][5] очень прост, но позволяет обойтись без использования популярных
CSS препроцессоров. Он так же имеет возможности по использованию вложенных
селекоторов, всплытия медиавыражений, импорта файлов, переменных, примесей.
В то же время он привносит больше гибкости, потому что это чистый JavaScript.
Он даже [работает с GruntJS][6]. Я был бы хотел получить обратную связь и был
бы рад, если вы примете участие в проекте. Официальный репозиторий находится
здесь [https://github.com/krasimir/absurd][7].

 [1]: https://github.com/krasimir/absurd
 [2]: img/concept.gif
 [3]: img/input.jpg
 [4]: http://krasimirtsonev.com/blog/article/Two-handy-and-advanced-SASS-features-and-their-limitations
 [5]: https://github.com/krasimir/absurd#usage
 [6]: https://github.com/krasimir/absurd#using-with-grunt
 [7]: https://github.com/krasimir/absurd